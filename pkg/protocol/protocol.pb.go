// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: protocol.proto

/*
	Package protocol is a generated protocol buffer package.

	It is generated from these files:
		protocol.proto

	It has these top-level messages:
		StatusResponse
		Label
		LabelSet
		LabelSelector
		JournalSpec
		BrokerSpec
		Fragment
		SHA1Sum
		ReadRequest
		ReadResponse
		AppendRequest
		AppendResponse
		ReplicateRequest
		ReplicateResponse
		Route
*/
package protocol

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/golang/protobuf/ptypes/duration"
import _ "github.com/golang/protobuf/ptypes/timestamp"

import time "time"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import binary "encoding/binary"
import types "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Status is a response status code, used universally across Gazette RPC APIs.
type Status int32

const (
	Status_OK                         Status = 0
	Status_JOURNAL_EXISTS             Status = 1
	Status_JOURNAL_NOT_FOUND          Status = 2
	Status_NO_JOURNAL_PRIMARY_BROKER  Status = 3
	Status_NOT_JOURNAL_PRIMARY_BROKER Status = 4
	Status_NO_JOURNAL_BROKERS         Status = 5
	Status_NOT_JOURNAL_BROKER         Status = 6
	Status_OFFSET_NOT_YET_AVAILABLE   Status = 7
	Status_REPLICATION_FAILED         Status = 8
	Status_WRONG_ROUTE                Status = 9
	Status_WRONG_WRITE_HEAD           Status = 10
)

var Status_name = map[int32]string{
	0:  "OK",
	1:  "JOURNAL_EXISTS",
	2:  "JOURNAL_NOT_FOUND",
	3:  "NO_JOURNAL_PRIMARY_BROKER",
	4:  "NOT_JOURNAL_PRIMARY_BROKER",
	5:  "NO_JOURNAL_BROKERS",
	6:  "NOT_JOURNAL_BROKER",
	7:  "OFFSET_NOT_YET_AVAILABLE",
	8:  "REPLICATION_FAILED",
	9:  "WRONG_ROUTE",
	10: "WRONG_WRITE_HEAD",
}
var Status_value = map[string]int32{
	"OK":                         0,
	"JOURNAL_EXISTS":             1,
	"JOURNAL_NOT_FOUND":          2,
	"NO_JOURNAL_PRIMARY_BROKER":  3,
	"NOT_JOURNAL_PRIMARY_BROKER": 4,
	"NO_JOURNAL_BROKERS":         5,
	"NOT_JOURNAL_BROKER":         6,
	"OFFSET_NOT_YET_AVAILABLE":   7,
	"REPLICATION_FAILED":         8,
	"WRONG_ROUTE":                9,
	"WRONG_WRITE_HEAD":           10,
}

func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}
func (Status) EnumDescriptor() ([]byte, []int) { return fileDescriptorProtocol, []int{0} }

// CompressionCode defines codecs known to Gazette.
type CompressionCodec int32

const (
	CompressionCodec_NONE      CompressionCodec = 0
	CompressionCodec_GZIP      CompressionCodec = 1
	CompressionCodec_ZSTANDARD CompressionCodec = 2
	CompressionCodec_SNAPPY    CompressionCodec = 3
	// CONTENT_ENCODING is not itself a CompressionCodec, but instead conveys
	// that the actual codec is stored under the Content-Encoding header of
	// the Fragment within the backing store.
	//
	// Deprecated. Going forward, we prefer to use explicit codec extensions.
	CompressionCodec_CONTENT_ENCODING CompressionCodec = 4
)

var CompressionCodec_name = map[int32]string{
	0: "NONE",
	1: "GZIP",
	2: "ZSTANDARD",
	3: "SNAPPY",
	4: "CONTENT_ENCODING",
}
var CompressionCodec_value = map[string]int32{
	"NONE":             0,
	"GZIP":             1,
	"ZSTANDARD":        2,
	"SNAPPY":           3,
	"CONTENT_ENCODING": 4,
}

func (x CompressionCodec) String() string {
	return proto.EnumName(CompressionCodec_name, int32(x))
}
func (CompressionCodec) EnumDescriptor() ([]byte, []int) { return fileDescriptorProtocol, []int{1} }

// StatusResponse is an RPC response representing a Status.
type StatusResponse struct {
	Status Status `protobuf:"varint,1,opt,name=status,proto3,enum=protocol.Status" json:"status,omitempty"`
}

func (m *StatusResponse) Reset()                    { *m = StatusResponse{} }
func (m *StatusResponse) String() string            { return proto.CompactTextString(m) }
func (*StatusResponse) ProtoMessage()               {}
func (*StatusResponse) Descriptor() ([]byte, []int) { return fileDescriptorProtocol, []int{0} }

func (m *StatusResponse) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return Status_OK
}

// Label defines a key & value pair which can be attached to entities like
// JournalSpecs and BrokerSpecs. Labels may be used to provide identifying
// attributes which do not directly imply semantics to the core system, but
// are meaningful to users or for higher-level Gazette tools. For example,
// topics of JournalSpecs are represented as the well-known label "topic".
type Label struct {
	Name  string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Label) Reset()                    { *m = Label{} }
func (m *Label) String() string            { return proto.CompactTextString(m) }
func (*Label) ProtoMessage()               {}
func (*Label) Descriptor() ([]byte, []int) { return fileDescriptorProtocol, []int{1} }

func (m *Label) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Label) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// LabelSet is a collection of labels and their values.
type LabelSet struct {
	// Labels of the set. Instances must be unique and in sorted order.
	Labels []Label `protobuf:"bytes,1,rep,name=labels" json:"labels"`
}

func (m *LabelSet) Reset()                    { *m = LabelSet{} }
func (m *LabelSet) String() string            { return proto.CompactTextString(m) }
func (*LabelSet) ProtoMessage()               {}
func (*LabelSet) Descriptor() ([]byte, []int) { return fileDescriptorProtocol, []int{2} }

func (m *LabelSet) GetLabels() []Label {
	if m != nil {
		return m.Labels
	}
	return nil
}

// LabelSelector defines a filter over LabelSets.
type LabelSelector struct {
	// Include is Labels which must be matched for a LabelSet to be selected. If
	// empty, all Labels are included. An include Label with empty ("") value is
	// matched by a Label of the same name having any value.
	Include LabelSet `protobuf:"bytes,1,opt,name=include" json:"include"`
	// Exclude is Labels which cannot be matched for a LabelSet to be selected. If
	// empty, no Labels are excluded. An exclude Label with empty ("") value
	// excludes a Label of the same name having any value.
	Exclude LabelSet `protobuf:"bytes,2,opt,name=exclude" json:"exclude"`
}

func (m *LabelSelector) Reset()                    { *m = LabelSelector{} }
func (m *LabelSelector) String() string            { return proto.CompactTextString(m) }
func (*LabelSelector) ProtoMessage()               {}
func (*LabelSelector) Descriptor() ([]byte, []int) { return fileDescriptorProtocol, []int{3} }

func (m *LabelSelector) GetInclude() LabelSet {
	if m != nil {
		return m.Include
	}
	return LabelSet{}
}

func (m *LabelSelector) GetExclude() LabelSet {
	if m != nil {
		return m.Exclude
	}
	return LabelSet{}
}

// JournalSpec describes a Journal and its configuration.
type JournalSpec struct {
	// Name of the Journal.
	Name Journal `protobuf:"bytes,1,opt,name=name,proto3,casttype=Journal" json:"name,omitempty"`
	// Desired replication of this Journal. This defines the Journal's tolerance
	// to broker failures before data loss can occur (eg, a replication factor
	// of three means two failures are tolerated).
	Replication int32 `protobuf:"varint,2,opt,name=replication,proto3" json:"replication,omitempty"`
	// User-defined Labels of this JournalSpec.
	Labels   LabelSet             `protobuf:"bytes,3,opt,name=labels" json:"labels"`
	Fragment JournalSpec_Fragment `protobuf:"bytes,4,opt,name=fragment" json:"fragment"`
	// Target content length of write transactions. While under this threshold,
	// the broker will seek to extend a current transaction by coalescing
	// additional ready Append RPCs. Once over this threshold, the broker will
	// commit the transaction at the completion of the current Append RPC.
	TransactionLength int64 `protobuf:"varint,5,opt,name=transaction_length,json=transactionLength,proto3" json:"transaction_length,omitempty"`
	// If true, this Journal will not accept Append requests.
	ReadOnly bool `protobuf:"varint,6,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
}

func (m *JournalSpec) Reset()                    { *m = JournalSpec{} }
func (m *JournalSpec) String() string            { return proto.CompactTextString(m) }
func (*JournalSpec) ProtoMessage()               {}
func (*JournalSpec) Descriptor() ([]byte, []int) { return fileDescriptorProtocol, []int{4} }

func (m *JournalSpec) GetName() Journal {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *JournalSpec) GetReplication() int32 {
	if m != nil {
		return m.Replication
	}
	return 0
}

func (m *JournalSpec) GetLabels() LabelSet {
	if m != nil {
		return m.Labels
	}
	return LabelSet{}
}

func (m *JournalSpec) GetFragment() JournalSpec_Fragment {
	if m != nil {
		return m.Fragment
	}
	return JournalSpec_Fragment{}
}

func (m *JournalSpec) GetTransactionLength() int64 {
	if m != nil {
		return m.TransactionLength
	}
	return 0
}

func (m *JournalSpec) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

// Fragment is JournalSpec configuration which pertains to the creation,
// persistence, and indexing of the Journal's Fragments.
type JournalSpec_Fragment struct {
	// Target content length of each Fragment. In normal operation after Fragments
	// reach at least this length, they will be closed and new ones begun. Note
	// lengths may be smaller at times (eg, due to changes in Journal routing
	// topology). Content length differs from Fragment file size, in that the
	// former reflects uncompressed bytes.
	Length int64 `protobuf:"varint,1,opt,name=length,proto3" json:"length,omitempty"`
	// Codec used to compress Journal Fragments.
	CompressionCodec CompressionCodec `protobuf:"varint,2,opt,name=compression_codec,json=compressionCodec,proto3,enum=protocol.CompressionCodec" json:"compression_codec,omitempty"`
	// Storage backend base path for this Journal's Fragments. Must be in URL
	// form, with the choice of backend defined by the scheme. The full path of
	// a Journal's Fragment is derived by joining the fragment_store path with
	// the Fragment's ContentPath. Eg, given a fragment_store of
	// "s3://My-AWS-bucket/a/prefix" and a JournalSpec of name "my/journal",
	// a complete Fragment path might be:
	//   "s3://My-AWS-bucket/a/prefix/my/journal/000123-000456-789abcdef.gzip
	//
	// Multiple fragment_stores may be specified, in which case the Journal's
	// Fragments are the union of all Fragments present across all stores, and
	// newly Fragments always persist to the first specified store. This can be
	// helpful in performing incremental migrations, where new Journal content is
	// written to the new store, while content in the old store remains available
	// (and, depending on fragment_retention or recovery log pruning, may
	// eventually be removed).
	//
	// If no fragment_stores are specified, the Journal is still useable but will
	// not persist Fragments to any a backing fragment store. This allows for
	// real-time streaming use cases where reads of historical data are not needed.
	Stores []FragmentStore `protobuf:"bytes,3,rep,name=stores,casttype=FragmentStore" json:"stores,omitempty"`
	// Interval of time between refreshes of remote Fragment listings from
	// configured fragment_stores.
	RefreshInterval time.Duration `protobuf:"bytes,4,opt,name=refresh_interval,json=refreshInterval,stdduration" json:"refresh_interval"`
	// Retention duration for historical Fragments of this Journal within the
	// Fragment stores. If zero, Fragments are retained indefinetely.
	Retention time.Duration `protobuf:"bytes,5,opt,name=retention,stdduration" json:"retention"`
}

func (m *JournalSpec_Fragment) Reset()                    { *m = JournalSpec_Fragment{} }
func (m *JournalSpec_Fragment) String() string            { return proto.CompactTextString(m) }
func (*JournalSpec_Fragment) ProtoMessage()               {}
func (*JournalSpec_Fragment) Descriptor() ([]byte, []int) { return fileDescriptorProtocol, []int{4, 0} }

func (m *JournalSpec_Fragment) GetLength() int64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *JournalSpec_Fragment) GetCompressionCodec() CompressionCodec {
	if m != nil {
		return m.CompressionCodec
	}
	return CompressionCodec_NONE
}

func (m *JournalSpec_Fragment) GetStores() []FragmentStore {
	if m != nil {
		return m.Stores
	}
	return nil
}

func (m *JournalSpec_Fragment) GetRefreshInterval() time.Duration {
	if m != nil {
		return m.RefreshInterval
	}
	return 0
}

func (m *JournalSpec_Fragment) GetRetention() time.Duration {
	if m != nil {
		return m.Retention
	}
	return 0
}

// BrokerSpec describes a Gazette broker and its configuration.
type BrokerSpec struct {
	Id BrokerSpec_ID `protobuf:"bytes,1,opt,name=id" json:"id"`
	// Advertised URL of the Broker.
	Endpoint Endpoint `protobuf:"bytes,2,opt,name=endpoint,proto3,casttype=Endpoint" json:"endpoint,omitempty"`
	// Maximum number of assigned Journal replicas.
	JournalLimit uint32 `protobuf:"varint,3,opt,name=journal_limit,json=journalLimit,proto3" json:"journal_limit,omitempty"`
}

func (m *BrokerSpec) Reset()                    { *m = BrokerSpec{} }
func (m *BrokerSpec) String() string            { return proto.CompactTextString(m) }
func (*BrokerSpec) ProtoMessage()               {}
func (*BrokerSpec) Descriptor() ([]byte, []int) { return fileDescriptorProtocol, []int{5} }

func (m *BrokerSpec) GetId() BrokerSpec_ID {
	if m != nil {
		return m.Id
	}
	return BrokerSpec_ID{}
}

func (m *BrokerSpec) GetEndpoint() Endpoint {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *BrokerSpec) GetJournalLimit() uint32 {
	if m != nil {
		return m.JournalLimit
	}
	return 0
}

type BrokerSpec_ID struct {
	// "Zone" in which the Broker is running. Zones may be AWS, Azure, or Google
	// Cloud Platform zone identifiers, or rack locations within a colo, or
	// given some other custom meaning. Gazette will replicate every Journal
	// across multiple zones, and seeks to minimize traffic which must cross zones
	// (for example, by proxying reads to a broker in the current zone).
	Zone string `protobuf:"bytes,1,opt,name=zone,proto3" json:"zone,omitempty"`
	// Unique suffix of the broker within |zone|.
	Suffix string `protobuf:"bytes,2,opt,name=suffix,proto3" json:"suffix,omitempty"`
}

func (m *BrokerSpec_ID) Reset()                    { *m = BrokerSpec_ID{} }
func (m *BrokerSpec_ID) String() string            { return proto.CompactTextString(m) }
func (*BrokerSpec_ID) ProtoMessage()               {}
func (*BrokerSpec_ID) Descriptor() ([]byte, []int) { return fileDescriptorProtocol, []int{5, 0} }

func (m *BrokerSpec_ID) GetZone() string {
	if m != nil {
		return m.Zone
	}
	return ""
}

func (m *BrokerSpec_ID) GetSuffix() string {
	if m != nil {
		return m.Suffix
	}
	return ""
}

type Fragment struct {
	// Journal of the Fragment.
	Journal Journal `protobuf:"bytes,1,opt,name=journal,proto3,casttype=Journal" json:"journal,omitempty"`
	// Begin (inclusive) and end (exclusive) offset of the Fragment within the Journal.
	Begin int64 `protobuf:"varint,2,opt,name=begin,proto3" json:"begin,omitempty"`
	End   int64 `protobuf:"varint,3,opt,name=end,proto3" json:"end,omitempty"`
	// SHA1 sum of the Fragment's content.
	Sum SHA1Sum `protobuf:"bytes,4,opt,name=sum" json:"sum"`
	// Codec with which the Fragment's content is compressed.
	CompressionCodec CompressionCodec `protobuf:"varint,5,opt,name=compression_codec,json=compressionCodec,proto3,enum=protocol.CompressionCodec" json:"compression_codec,omitempty"`
	// Fragment store which backs the Fragment. Empty if the Fragment has yet to
	// be persisted and is still local to a Broker.
	BackingStore string `protobuf:"bytes,6,opt,name=backing_store,json=backingStore,proto3" json:"backing_store,omitempty"`
	// Modification timestamp of the Fragment within the backing store.
	ModTime time.Time `protobuf:"bytes,7,opt,name=mod_time,json=modTime,stdtime" json:"mod_time"`
}

func (m *Fragment) Reset()                    { *m = Fragment{} }
func (m *Fragment) String() string            { return proto.CompactTextString(m) }
func (*Fragment) ProtoMessage()               {}
func (*Fragment) Descriptor() ([]byte, []int) { return fileDescriptorProtocol, []int{6} }

func (m *Fragment) GetJournal() Journal {
	if m != nil {
		return m.Journal
	}
	return ""
}

func (m *Fragment) GetBegin() int64 {
	if m != nil {
		return m.Begin
	}
	return 0
}

func (m *Fragment) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *Fragment) GetSum() SHA1Sum {
	if m != nil {
		return m.Sum
	}
	return SHA1Sum{}
}

func (m *Fragment) GetCompressionCodec() CompressionCodec {
	if m != nil {
		return m.CompressionCodec
	}
	return CompressionCodec_NONE
}

func (m *Fragment) GetBackingStore() string {
	if m != nil {
		return m.BackingStore
	}
	return ""
}

func (m *Fragment) GetModTime() time.Time {
	if m != nil {
		return m.ModTime
	}
	return time.Time{}
}

// SHA1Sum is a 160-bit SHA1 digest.
type SHA1Sum struct {
	Part1 uint64 `protobuf:"fixed64,1,opt,name=part1,proto3" json:"part1,omitempty"`
	Part2 uint64 `protobuf:"fixed64,2,opt,name=part2,proto3" json:"part2,omitempty"`
	Part3 uint32 `protobuf:"fixed32,3,opt,name=part3,proto3" json:"part3,omitempty"`
}

func (m *SHA1Sum) Reset()                    { *m = SHA1Sum{} }
func (m *SHA1Sum) String() string            { return proto.CompactTextString(m) }
func (*SHA1Sum) ProtoMessage()               {}
func (*SHA1Sum) Descriptor() ([]byte, []int) { return fileDescriptorProtocol, []int{7} }

func (m *SHA1Sum) GetPart1() uint64 {
	if m != nil {
		return m.Part1
	}
	return 0
}

func (m *SHA1Sum) GetPart2() uint64 {
	if m != nil {
		return m.Part2
	}
	return 0
}

func (m *SHA1Sum) GetPart3() uint32 {
	if m != nil {
		return m.Part3
	}
	return 0
}

type ReadRequest struct {
	// Journal to be read.
	Journal Journal `protobuf:"bytes,1,opt,name=journal,proto3,casttype=Journal" json:"journal,omitempty"`
	// Desired offset to begin reading from. Value -1 has special handling, where
	// the read is performed from the current write head. All other positive
	// values specify a desired exact byte offset to read from. If the offset is
	// not available (eg, because it represents a portion of Journal which has
	// been permantently deleted), the broker will return the next available
	// offset. Callers should therefore always inspect the ReadResponse offset.
	Offset int64 `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	// Whether the operation should block until content becomes available.
	// OFFSET_NOT_YET_AVAILABLE is returned if a non-blocking read has no ready content.
	Block bool `protobuf:"varint,3,opt,name=block,proto3" json:"block,omitempty"`
	// If do_not_proxy is true, the broker will not proxy the read to another
	// broker, or open and proxy a remote Fragment on the client's behalf.
	DoNotProxy bool `protobuf:"varint,4,opt,name=do_not_proxy,json=doNotProxy,proto3" json:"do_not_proxy,omitempty"`
	// If metadata_only is true, the broker will respond with Journal and
	// Fragment metadata but not content.
	MetadataOnly bool `protobuf:"varint,5,opt,name=metadata_only,json=metadataOnly,proto3" json:"metadata_only,omitempty"`
}

func (m *ReadRequest) Reset()                    { *m = ReadRequest{} }
func (m *ReadRequest) String() string            { return proto.CompactTextString(m) }
func (*ReadRequest) ProtoMessage()               {}
func (*ReadRequest) Descriptor() ([]byte, []int) { return fileDescriptorProtocol, []int{8} }

func (m *ReadRequest) GetJournal() Journal {
	if m != nil {
		return m.Journal
	}
	return ""
}

func (m *ReadRequest) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *ReadRequest) GetBlock() bool {
	if m != nil {
		return m.Block
	}
	return false
}

func (m *ReadRequest) GetDoNotProxy() bool {
	if m != nil {
		return m.DoNotProxy
	}
	return false
}

func (m *ReadRequest) GetMetadataOnly() bool {
	if m != nil {
		return m.MetadataOnly
	}
	return false
}

type ReadResponse struct {
	Status Status `protobuf:"varint,1,opt,name=status,proto3,enum=protocol.Status" json:"status,omitempty"`
	// The effective offset of the read. See ReadRequest offset.
	Offset int64 `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	// The offset to next be written, by the next append transaction served by
	// broker. In other words, the last offset through which content is
	// available to be read from the Journal.
	WriteHead int64 `protobuf:"varint,3,opt,name=write_head,json=writeHead,proto3" json:"write_head,omitempty"`
	// The route of responsible brokers for the current Journal.
	Route *Route `protobuf:"bytes,4,opt,name=route" json:"route,omitempty"`
	// Fragment to which the offset was mapped.
	Fragment *Fragment `protobuf:"bytes,5,opt,name=fragment" json:"fragment,omitempty"`
	// If Fragment is remote, a URL from which it may be directly read.
	FragmentUrl string `protobuf:"bytes,6,opt,name=fragment_url,json=fragmentUrl,proto3" json:"fragment_url,omitempty"`
	// Content of the read.
	Content []byte `protobuf:"bytes,7,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *ReadResponse) Reset()                    { *m = ReadResponse{} }
func (m *ReadResponse) String() string            { return proto.CompactTextString(m) }
func (*ReadResponse) ProtoMessage()               {}
func (*ReadResponse) Descriptor() ([]byte, []int) { return fileDescriptorProtocol, []int{9} }

func (m *ReadResponse) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return Status_OK
}

func (m *ReadResponse) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *ReadResponse) GetWriteHead() int64 {
	if m != nil {
		return m.WriteHead
	}
	return 0
}

func (m *ReadResponse) GetRoute() *Route {
	if m != nil {
		return m.Route
	}
	return nil
}

func (m *ReadResponse) GetFragment() *Fragment {
	if m != nil {
		return m.Fragment
	}
	return nil
}

func (m *ReadResponse) GetFragmentUrl() string {
	if m != nil {
		return m.FragmentUrl
	}
	return ""
}

func (m *ReadResponse) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

type AppendRequest struct {
	// Journal to be appended to.
	Journal Journal `protobuf:"bytes,1,opt,name=journal,proto3,casttype=Journal" json:"journal,omitempty"`
	// Content to be appended.
	Content []byte `protobuf:"bytes,5,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *AppendRequest) Reset()                    { *m = AppendRequest{} }
func (m *AppendRequest) String() string            { return proto.CompactTextString(m) }
func (*AppendRequest) ProtoMessage()               {}
func (*AppendRequest) Descriptor() ([]byte, []int) { return fileDescriptorProtocol, []int{10} }

func (m *AppendRequest) GetJournal() Journal {
	if m != nil {
		return m.Journal
	}
	return ""
}

func (m *AppendRequest) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

type AppendResponse struct {
	Status Status `protobuf:"varint,1,opt,name=status,proto3,enum=protocol.Status" json:"status,omitempty"`
	// The route of responsible brokers for the current Journal.
	Route *Route `protobuf:"bytes,2,opt,name=route" json:"route,omitempty"`
	// On Status OK, the [first_offset, last_offset) byte range at which the
	// Append was committed to the log.
	FirstOffset int64 `protobuf:"varint,3,opt,name=first_offset,json=firstOffset,proto3" json:"first_offset,omitempty"`
	LastOffset  int64 `protobuf:"varint,4,opt,name=last_offset,json=lastOffset,proto3" json:"last_offset,omitempty"`
	// On Status OK, the write_head at the time of the Append request completion.
	// This may be equal to or larger than last_offset, as multiple Appends may
	// have been coalesced within a single replicated transaction.
	WriteHead int64 `protobuf:"varint,5,opt,name=write_head,json=writeHead,proto3" json:"write_head,omitempty"`
}

func (m *AppendResponse) Reset()                    { *m = AppendResponse{} }
func (m *AppendResponse) String() string            { return proto.CompactTextString(m) }
func (*AppendResponse) ProtoMessage()               {}
func (*AppendResponse) Descriptor() ([]byte, []int) { return fileDescriptorProtocol, []int{11} }

func (m *AppendResponse) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return Status_OK
}

func (m *AppendResponse) GetRoute() *Route {
	if m != nil {
		return m.Route
	}
	return nil
}

func (m *AppendResponse) GetFirstOffset() int64 {
	if m != nil {
		return m.FirstOffset
	}
	return 0
}

func (m *AppendResponse) GetLastOffset() int64 {
	if m != nil {
		return m.LastOffset
	}
	return 0
}

func (m *AppendResponse) GetWriteHead() int64 {
	if m != nil {
		return m.WriteHead
	}
	return 0
}

type ReplicateRequest struct {
	// Journal to be replicated to.
	Journal Journal `protobuf:"bytes,1,opt,name=journal,proto3,casttype=Journal" json:"journal,omitempty"`
	// Next offset to be written within the Journal. next_offset is independently
	// verified by each Journal replica.
	NextOffset int64 `protobuf:"varint,2,opt,name=next_offset,json=nextOffset,proto3" json:"next_offset,omitempty"`
	// Route of the transaction, also known and verified by all replicas.
	Route *Route `protobuf:"bytes,3,opt,name=route" json:"route,omitempty"`
	// Content to be replicated. Present on ReplicateRequest messages after
	// the first (and after a Status_OK ReplicateResponse has been sent).
	// Empty content signals that the transaction has completed.
	Content []byte `protobuf:"bytes,4,opt,name=content,proto3" json:"content,omitempty"`
	// Bytes to be comitted. Pair with an empty |content| field.
	Commit int64 `protobuf:"varint,5,opt,name=commit,proto3" json:"commit,omitempty"`
}

func (m *ReplicateRequest) Reset()                    { *m = ReplicateRequest{} }
func (m *ReplicateRequest) String() string            { return proto.CompactTextString(m) }
func (*ReplicateRequest) ProtoMessage()               {}
func (*ReplicateRequest) Descriptor() ([]byte, []int) { return fileDescriptorProtocol, []int{12} }

func (m *ReplicateRequest) GetJournal() Journal {
	if m != nil {
		return m.Journal
	}
	return ""
}

func (m *ReplicateRequest) GetNextOffset() int64 {
	if m != nil {
		return m.NextOffset
	}
	return 0
}

func (m *ReplicateRequest) GetRoute() *Route {
	if m != nil {
		return m.Route
	}
	return nil
}

func (m *ReplicateRequest) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *ReplicateRequest) GetCommit() int64 {
	if m != nil {
		return m.Commit
	}
	return 0
}

type ReplicateResponse struct {
	Status Status `protobuf:"varint,1,opt,name=status,proto3,enum=protocol.Status" json:"status,omitempty"`
	// If status is WRONG_WRITE_HEAD, then |write_head| is the replica's
	// own, strictly greater write head.
	WriteHead int64 `protobuf:"varint,2,opt,name=write_head,json=writeHead,proto3" json:"write_head,omitempty"`
	// If status is WRONG_ROUTE_TOKEN, then |route| is the replica's Route
	// which was found to be inconsistent with the request Route.
	Route *Route `protobuf:"bytes,3,opt,name=route" json:"route,omitempty"`
}

func (m *ReplicateResponse) Reset()                    { *m = ReplicateResponse{} }
func (m *ReplicateResponse) String() string            { return proto.CompactTextString(m) }
func (*ReplicateResponse) ProtoMessage()               {}
func (*ReplicateResponse) Descriptor() ([]byte, []int) { return fileDescriptorProtocol, []int{13} }

func (m *ReplicateResponse) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return Status_OK
}

func (m *ReplicateResponse) GetWriteHead() int64 {
	if m != nil {
		return m.WriteHead
	}
	return 0
}

func (m *ReplicateResponse) GetRoute() *Route {
	if m != nil {
		return m.Route
	}
	return nil
}

// Route captures the current topology of a Journal and the brokers serving it.
type Route struct {
	// Brokers of the Route, ordered on ascending BrokerSpec (zone, name).
	// Note that only a Route-relevant subset of the spec is populated
	// (specifically name, zone, & endpoint).
	Brokers []BrokerSpec_ID `protobuf:"bytes,1,rep,name=brokers" json:"brokers"`
	// Index of the BrokerSpec serving as primary within |brokers|,
	// or -1 of no broker is currently primary.
	Primary int32 `protobuf:"varint,2,opt,name=primary,proto3" json:"primary,omitempty"`
	// Endpoints of each Route Broker. If not empty, |endpoints| has the same
	// length and order as |brokers|, and captures the endpoint of each one.
	Endpoints []Endpoint `protobuf:"bytes,3,rep,name=endpoints,casttype=Endpoint" json:"endpoints,omitempty"`
}

func (m *Route) Reset()                    { *m = Route{} }
func (m *Route) String() string            { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()               {}
func (*Route) Descriptor() ([]byte, []int) { return fileDescriptorProtocol, []int{14} }

func (m *Route) GetBrokers() []BrokerSpec_ID {
	if m != nil {
		return m.Brokers
	}
	return nil
}

func (m *Route) GetPrimary() int32 {
	if m != nil {
		return m.Primary
	}
	return 0
}

func (m *Route) GetEndpoints() []Endpoint {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

func init() {
	proto.RegisterType((*StatusResponse)(nil), "protocol.StatusResponse")
	proto.RegisterType((*Label)(nil), "protocol.Label")
	proto.RegisterType((*LabelSet)(nil), "protocol.LabelSet")
	proto.RegisterType((*LabelSelector)(nil), "protocol.LabelSelector")
	proto.RegisterType((*JournalSpec)(nil), "protocol.JournalSpec")
	proto.RegisterType((*JournalSpec_Fragment)(nil), "protocol.JournalSpec.Fragment")
	proto.RegisterType((*BrokerSpec)(nil), "protocol.BrokerSpec")
	proto.RegisterType((*BrokerSpec_ID)(nil), "protocol.BrokerSpec.ID")
	proto.RegisterType((*Fragment)(nil), "protocol.Fragment")
	proto.RegisterType((*SHA1Sum)(nil), "protocol.SHA1Sum")
	proto.RegisterType((*ReadRequest)(nil), "protocol.ReadRequest")
	proto.RegisterType((*ReadResponse)(nil), "protocol.ReadResponse")
	proto.RegisterType((*AppendRequest)(nil), "protocol.AppendRequest")
	proto.RegisterType((*AppendResponse)(nil), "protocol.AppendResponse")
	proto.RegisterType((*ReplicateRequest)(nil), "protocol.ReplicateRequest")
	proto.RegisterType((*ReplicateResponse)(nil), "protocol.ReplicateResponse")
	proto.RegisterType((*Route)(nil), "protocol.Route")
	proto.RegisterEnum("protocol.Status", Status_name, Status_value)
	proto.RegisterEnum("protocol.CompressionCodec", CompressionCodec_name, CompressionCodec_value)
}
func (this *SHA1Sum) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SHA1Sum)
	if !ok {
		that2, ok := that.(SHA1Sum)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Part1 != that1.Part1 {
		return false
	}
	if this.Part2 != that1.Part2 {
		return false
	}
	if this.Part3 != that1.Part3 {
		return false
	}
	return true
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Broker service

type BrokerClient interface {
	Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (Broker_ReadClient, error)
	Append(ctx context.Context, opts ...grpc.CallOption) (Broker_AppendClient, error)
	Replicate(ctx context.Context, opts ...grpc.CallOption) (Broker_ReplicateClient, error)
}

type brokerClient struct {
	cc *grpc.ClientConn
}

func NewBrokerClient(cc *grpc.ClientConn) BrokerClient {
	return &brokerClient{cc}
}

func (c *brokerClient) Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (Broker_ReadClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Broker_serviceDesc.Streams[0], c.cc, "/protocol.Broker/Read", opts...)
	if err != nil {
		return nil, err
	}
	x := &brokerReadClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Broker_ReadClient interface {
	Recv() (*ReadResponse, error)
	grpc.ClientStream
}

type brokerReadClient struct {
	grpc.ClientStream
}

func (x *brokerReadClient) Recv() (*ReadResponse, error) {
	m := new(ReadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *brokerClient) Append(ctx context.Context, opts ...grpc.CallOption) (Broker_AppendClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Broker_serviceDesc.Streams[1], c.cc, "/protocol.Broker/Append", opts...)
	if err != nil {
		return nil, err
	}
	x := &brokerAppendClient{stream}
	return x, nil
}

type Broker_AppendClient interface {
	Send(*AppendRequest) error
	CloseAndRecv() (*AppendResponse, error)
	grpc.ClientStream
}

type brokerAppendClient struct {
	grpc.ClientStream
}

func (x *brokerAppendClient) Send(m *AppendRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *brokerAppendClient) CloseAndRecv() (*AppendResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(AppendResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *brokerClient) Replicate(ctx context.Context, opts ...grpc.CallOption) (Broker_ReplicateClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Broker_serviceDesc.Streams[2], c.cc, "/protocol.Broker/Replicate", opts...)
	if err != nil {
		return nil, err
	}
	x := &brokerReplicateClient{stream}
	return x, nil
}

type Broker_ReplicateClient interface {
	Send(*ReplicateRequest) error
	Recv() (*ReplicateResponse, error)
	grpc.ClientStream
}

type brokerReplicateClient struct {
	grpc.ClientStream
}

func (x *brokerReplicateClient) Send(m *ReplicateRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *brokerReplicateClient) Recv() (*ReplicateResponse, error) {
	m := new(ReplicateResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Broker service

type BrokerServer interface {
	Read(*ReadRequest, Broker_ReadServer) error
	Append(Broker_AppendServer) error
	Replicate(Broker_ReplicateServer) error
}

func RegisterBrokerServer(s *grpc.Server, srv BrokerServer) {
	s.RegisterService(&_Broker_serviceDesc, srv)
}

func _Broker_Read_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BrokerServer).Read(m, &brokerReadServer{stream})
}

type Broker_ReadServer interface {
	Send(*ReadResponse) error
	grpc.ServerStream
}

type brokerReadServer struct {
	grpc.ServerStream
}

func (x *brokerReadServer) Send(m *ReadResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Broker_Append_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BrokerServer).Append(&brokerAppendServer{stream})
}

type Broker_AppendServer interface {
	SendAndClose(*AppendResponse) error
	Recv() (*AppendRequest, error)
	grpc.ServerStream
}

type brokerAppendServer struct {
	grpc.ServerStream
}

func (x *brokerAppendServer) SendAndClose(m *AppendResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *brokerAppendServer) Recv() (*AppendRequest, error) {
	m := new(AppendRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Broker_Replicate_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BrokerServer).Replicate(&brokerReplicateServer{stream})
}

type Broker_ReplicateServer interface {
	Send(*ReplicateResponse) error
	Recv() (*ReplicateRequest, error)
	grpc.ServerStream
}

type brokerReplicateServer struct {
	grpc.ServerStream
}

func (x *brokerReplicateServer) Send(m *ReplicateResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *brokerReplicateServer) Recv() (*ReplicateRequest, error) {
	m := new(ReplicateRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Broker_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protocol.Broker",
	HandlerType: (*BrokerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Read",
			Handler:       _Broker_Read_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Append",
			Handler:       _Broker_Append_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Replicate",
			Handler:       _Broker_Replicate_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "protocol.proto",
}

func (m *StatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *Label) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Label) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *LabelSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabelSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for _, msg := range m.Labels {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProtocol(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *LabelSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabelSelector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProtocol(dAtA, i, uint64(m.Include.Size()))
	n1, err := m.Include.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintProtocol(dAtA, i, uint64(m.Exclude.Size()))
	n2, err := m.Exclude.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	return i, nil
}

func (m *JournalSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JournalSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Replication != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(m.Replication))
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintProtocol(dAtA, i, uint64(m.Labels.Size()))
	n3, err := m.Labels.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintProtocol(dAtA, i, uint64(m.Fragment.Size()))
	n4, err := m.Fragment.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if m.TransactionLength != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(m.TransactionLength))
	}
	if m.ReadOnly {
		dAtA[i] = 0x30
		i++
		if m.ReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *JournalSpec_Fragment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JournalSpec_Fragment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Length != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(m.Length))
	}
	if m.CompressionCodec != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(m.CompressionCodec))
	}
	if len(m.Stores) > 0 {
		for _, s := range m.Stores {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintProtocol(dAtA, i, uint64(types.SizeOfStdDuration(m.RefreshInterval)))
	n5, err := types.StdDurationMarshalTo(m.RefreshInterval, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x2a
	i++
	i = encodeVarintProtocol(dAtA, i, uint64(types.SizeOfStdDuration(m.Retention)))
	n6, err := types.StdDurationMarshalTo(m.Retention, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	return i, nil
}

func (m *BrokerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BrokerSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProtocol(dAtA, i, uint64(m.Id.Size()))
	n7, err := m.Id.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	if len(m.Endpoint) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.Endpoint)))
		i += copy(dAtA[i:], m.Endpoint)
	}
	if m.JournalLimit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(m.JournalLimit))
	}
	return i, nil
}

func (m *BrokerSpec_ID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BrokerSpec_ID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Zone) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.Zone)))
		i += copy(dAtA[i:], m.Zone)
	}
	if len(m.Suffix) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.Suffix)))
		i += copy(dAtA[i:], m.Suffix)
	}
	return i, nil
}

func (m *Fragment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Fragment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Journal) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.Journal)))
		i += copy(dAtA[i:], m.Journal)
	}
	if m.Begin != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(m.Begin))
	}
	if m.End != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(m.End))
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintProtocol(dAtA, i, uint64(m.Sum.Size()))
	n8, err := m.Sum.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	if m.CompressionCodec != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(m.CompressionCodec))
	}
	if len(m.BackingStore) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.BackingStore)))
		i += copy(dAtA[i:], m.BackingStore)
	}
	dAtA[i] = 0x3a
	i++
	i = encodeVarintProtocol(dAtA, i, uint64(types.SizeOfStdTime(m.ModTime)))
	n9, err := types.StdTimeMarshalTo(m.ModTime, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	return i, nil
}

func (m *SHA1Sum) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SHA1Sum) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Part1 != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Part1))
		i += 8
	}
	if m.Part2 != 0 {
		dAtA[i] = 0x11
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Part2))
		i += 8
	}
	if m.Part3 != 0 {
		dAtA[i] = 0x1d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.Part3))
		i += 4
	}
	return i, nil
}

func (m *ReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Journal) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.Journal)))
		i += copy(dAtA[i:], m.Journal)
	}
	if m.Offset != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(m.Offset))
	}
	if m.Block {
		dAtA[i] = 0x18
		i++
		if m.Block {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DoNotProxy {
		dAtA[i] = 0x20
		i++
		if m.DoNotProxy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MetadataOnly {
		dAtA[i] = 0x28
		i++
		if m.MetadataOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ReadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(m.Status))
	}
	if m.Offset != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(m.Offset))
	}
	if m.WriteHead != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(m.WriteHead))
	}
	if m.Route != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(m.Route.Size()))
		n10, err := m.Route.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Fragment != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(m.Fragment.Size()))
		n11, err := m.Fragment.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.FragmentUrl) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.FragmentUrl)))
		i += copy(dAtA[i:], m.FragmentUrl)
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	return i, nil
}

func (m *AppendRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Journal) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.Journal)))
		i += copy(dAtA[i:], m.Journal)
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	return i, nil
}

func (m *AppendResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(m.Status))
	}
	if m.Route != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(m.Route.Size()))
		n12, err := m.Route.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.FirstOffset != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(m.FirstOffset))
	}
	if m.LastOffset != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(m.LastOffset))
	}
	if m.WriteHead != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(m.WriteHead))
	}
	return i, nil
}

func (m *ReplicateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicateRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Journal) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.Journal)))
		i += copy(dAtA[i:], m.Journal)
	}
	if m.NextOffset != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(m.NextOffset))
	}
	if m.Route != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(m.Route.Size()))
		n13, err := m.Route.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if m.Commit != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(m.Commit))
	}
	return i, nil
}

func (m *ReplicateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicateResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(m.Status))
	}
	if m.WriteHead != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(m.WriteHead))
	}
	if m.Route != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(m.Route.Size()))
		n14, err := m.Route.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *Route) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Route) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Brokers) > 0 {
		for _, msg := range m.Brokers {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProtocol(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Primary != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtocol(dAtA, i, uint64(m.Primary))
	}
	if len(m.Endpoints) > 0 {
		for _, s := range m.Endpoints {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func encodeVarintProtocol(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *StatusResponse) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovProtocol(uint64(m.Status))
	}
	return n
}

func (m *Label) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	return n
}

func (m *LabelSet) Size() (n int) {
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovProtocol(uint64(l))
		}
	}
	return n
}

func (m *LabelSelector) Size() (n int) {
	var l int
	_ = l
	l = m.Include.Size()
	n += 1 + l + sovProtocol(uint64(l))
	l = m.Exclude.Size()
	n += 1 + l + sovProtocol(uint64(l))
	return n
}

func (m *JournalSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	if m.Replication != 0 {
		n += 1 + sovProtocol(uint64(m.Replication))
	}
	l = m.Labels.Size()
	n += 1 + l + sovProtocol(uint64(l))
	l = m.Fragment.Size()
	n += 1 + l + sovProtocol(uint64(l))
	if m.TransactionLength != 0 {
		n += 1 + sovProtocol(uint64(m.TransactionLength))
	}
	if m.ReadOnly {
		n += 2
	}
	return n
}

func (m *JournalSpec_Fragment) Size() (n int) {
	var l int
	_ = l
	if m.Length != 0 {
		n += 1 + sovProtocol(uint64(m.Length))
	}
	if m.CompressionCodec != 0 {
		n += 1 + sovProtocol(uint64(m.CompressionCodec))
	}
	if len(m.Stores) > 0 {
		for _, s := range m.Stores {
			l = len(s)
			n += 1 + l + sovProtocol(uint64(l))
		}
	}
	l = types.SizeOfStdDuration(m.RefreshInterval)
	n += 1 + l + sovProtocol(uint64(l))
	l = types.SizeOfStdDuration(m.Retention)
	n += 1 + l + sovProtocol(uint64(l))
	return n
}

func (m *BrokerSpec) Size() (n int) {
	var l int
	_ = l
	l = m.Id.Size()
	n += 1 + l + sovProtocol(uint64(l))
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	if m.JournalLimit != 0 {
		n += 1 + sovProtocol(uint64(m.JournalLimit))
	}
	return n
}

func (m *BrokerSpec_ID) Size() (n int) {
	var l int
	_ = l
	l = len(m.Zone)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	l = len(m.Suffix)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	return n
}

func (m *Fragment) Size() (n int) {
	var l int
	_ = l
	l = len(m.Journal)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	if m.Begin != 0 {
		n += 1 + sovProtocol(uint64(m.Begin))
	}
	if m.End != 0 {
		n += 1 + sovProtocol(uint64(m.End))
	}
	l = m.Sum.Size()
	n += 1 + l + sovProtocol(uint64(l))
	if m.CompressionCodec != 0 {
		n += 1 + sovProtocol(uint64(m.CompressionCodec))
	}
	l = len(m.BackingStore)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	l = types.SizeOfStdTime(m.ModTime)
	n += 1 + l + sovProtocol(uint64(l))
	return n
}

func (m *SHA1Sum) Size() (n int) {
	var l int
	_ = l
	if m.Part1 != 0 {
		n += 9
	}
	if m.Part2 != 0 {
		n += 9
	}
	if m.Part3 != 0 {
		n += 5
	}
	return n
}

func (m *ReadRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Journal)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	if m.Offset != 0 {
		n += 1 + sovProtocol(uint64(m.Offset))
	}
	if m.Block {
		n += 2
	}
	if m.DoNotProxy {
		n += 2
	}
	if m.MetadataOnly {
		n += 2
	}
	return n
}

func (m *ReadResponse) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovProtocol(uint64(m.Status))
	}
	if m.Offset != 0 {
		n += 1 + sovProtocol(uint64(m.Offset))
	}
	if m.WriteHead != 0 {
		n += 1 + sovProtocol(uint64(m.WriteHead))
	}
	if m.Route != nil {
		l = m.Route.Size()
		n += 1 + l + sovProtocol(uint64(l))
	}
	if m.Fragment != nil {
		l = m.Fragment.Size()
		n += 1 + l + sovProtocol(uint64(l))
	}
	l = len(m.FragmentUrl)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	return n
}

func (m *AppendRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Journal)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	return n
}

func (m *AppendResponse) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovProtocol(uint64(m.Status))
	}
	if m.Route != nil {
		l = m.Route.Size()
		n += 1 + l + sovProtocol(uint64(l))
	}
	if m.FirstOffset != 0 {
		n += 1 + sovProtocol(uint64(m.FirstOffset))
	}
	if m.LastOffset != 0 {
		n += 1 + sovProtocol(uint64(m.LastOffset))
	}
	if m.WriteHead != 0 {
		n += 1 + sovProtocol(uint64(m.WriteHead))
	}
	return n
}

func (m *ReplicateRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Journal)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	if m.NextOffset != 0 {
		n += 1 + sovProtocol(uint64(m.NextOffset))
	}
	if m.Route != nil {
		l = m.Route.Size()
		n += 1 + l + sovProtocol(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	if m.Commit != 0 {
		n += 1 + sovProtocol(uint64(m.Commit))
	}
	return n
}

func (m *ReplicateResponse) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovProtocol(uint64(m.Status))
	}
	if m.WriteHead != 0 {
		n += 1 + sovProtocol(uint64(m.WriteHead))
	}
	if m.Route != nil {
		l = m.Route.Size()
		n += 1 + l + sovProtocol(uint64(l))
	}
	return n
}

func (m *Route) Size() (n int) {
	var l int
	_ = l
	if len(m.Brokers) > 0 {
		for _, e := range m.Brokers {
			l = e.Size()
			n += 1 + l + sovProtocol(uint64(l))
		}
	}
	if m.Primary != 0 {
		n += 1 + sovProtocol(uint64(m.Primary))
	}
	if len(m.Endpoints) > 0 {
		for _, s := range m.Endpoints {
			l = len(s)
			n += 1 + l + sovProtocol(uint64(l))
		}
	}
	return n
}

func sovProtocol(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozProtocol(x uint64) (n int) {
	return sovProtocol(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *StatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Label) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Label: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Label: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabelSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabelSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabelSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, Label{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabelSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabelSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabelSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Include", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Include.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exclude", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Exclude.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JournalSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JournalSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JournalSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = Journal(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replication", wireType)
			}
			m.Replication = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Replication |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Labels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fragment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Fragment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionLength", wireType)
			}
			m.TransactionLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransactionLength |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JournalSpec_Fragment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fragment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fragment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionCodec", wireType)
			}
			m.CompressionCodec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompressionCodec |= (CompressionCodec(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stores", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stores = append(m.Stores, FragmentStore(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := types.StdDurationUnmarshal(&m.RefreshInterval, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retention", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := types.StdDurationUnmarshal(&m.Retention, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BrokerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BrokerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BrokerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = Endpoint(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JournalLimit", wireType)
			}
			m.JournalLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JournalLimit |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BrokerSpec_ID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suffix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Suffix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Fragment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fragment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fragment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Journal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Journal = Journal(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			m.Begin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Begin |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Sum.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionCodec", wireType)
			}
			m.CompressionCodec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompressionCodec |= (CompressionCodec(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackingStore", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackingStore = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := types.StdTimeUnmarshal(&m.ModTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SHA1Sum) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SHA1Sum: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SHA1Sum: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Part1", wireType)
			}
			m.Part1 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Part1 = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Part2", wireType)
			}
			m.Part2 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Part2 = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Part3", wireType)
			}
			m.Part3 = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.Part3 = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Journal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Journal = Journal(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Block = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoNotProxy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DoNotProxy = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MetadataOnly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteHead", wireType)
			}
			m.WriteHead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteHead |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Route == nil {
				m.Route = &Route{}
			}
			if err := m.Route.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fragment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fragment == nil {
				m.Fragment = &Fragment{}
			}
			if err := m.Fragment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragmentUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FragmentUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Journal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Journal = Journal(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Route == nil {
				m.Route = &Route{}
			}
			if err := m.Route.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstOffset", wireType)
			}
			m.FirstOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FirstOffset |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastOffset", wireType)
			}
			m.LastOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastOffset |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteHead", wireType)
			}
			m.WriteHead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteHead |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Journal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Journal = Journal(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextOffset", wireType)
			}
			m.NextOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextOffset |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Route == nil {
				m.Route = &Route{}
			}
			if err := m.Route.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			m.Commit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Commit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteHead", wireType)
			}
			m.WriteHead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteHead |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Route == nil {
				m.Route = &Route{}
			}
			if err := m.Route.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Route) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Route: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Route: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Brokers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Brokers = append(m.Brokers, BrokerSpec_ID{})
			if err := m.Brokers[len(m.Brokers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Primary", wireType)
			}
			m.Primary = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Primary |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoints", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoints = append(m.Endpoints, Endpoint(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProtocol(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthProtocol
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowProtocol
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipProtocol(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthProtocol = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProtocol   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("protocol.proto", fileDescriptorProtocol) }

var fileDescriptorProtocol = []byte{
	// 1431 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0x3d, 0x73, 0xdb, 0x46,
	0x13, 0x16, 0xf8, 0x09, 0x2e, 0x29, 0x19, 0xba, 0xb1, 0xf5, 0xd2, 0xf4, 0x6b, 0x51, 0x2f, 0x3d,
	0x9e, 0xa1, 0x3d, 0x23, 0x5a, 0xa6, 0x0b, 0xcf, 0xeb, 0x99, 0x4c, 0x42, 0x8a, 0x94, 0x44, 0x9b,
	0x01, 0x34, 0x47, 0x2a, 0x8e, 0xdd, 0x60, 0x20, 0xe0, 0x44, 0x21, 0x06, 0x71, 0x0c, 0x08, 0xda,
	0x52, 0x5a, 0x17, 0x69, 0x52, 0xa4, 0x4c, 0x99, 0x94, 0xae, 0xdd, 0xba, 0x4c, 0xe1, 0x49, 0xe5,
	0x5f, 0xa0, 0x64, 0x5c, 0xe5, 0x37, 0xb8, 0xca, 0xdc, 0x07, 0x48, 0x88, 0x96, 0x3f, 0x94, 0x0e,
	0xfb, 0xec, 0xee, 0xdd, 0xde, 0xb3, 0xcf, 0xed, 0x01, 0x96, 0x46, 0x01, 0x0d, 0xa9, 0x4d, 0xbd,
	0x1a, 0xff, 0x40, 0x6a, 0x64, 0x97, 0xd6, 0x07, 0x6e, 0x78, 0x38, 0xd9, 0xaf, 0xd9, 0x74, 0x78,
	0x6b, 0x40, 0x07, 0xf4, 0x16, 0xf7, 0xec, 0x4f, 0x0e, 0xb8, 0xc5, 0x0d, 0xfe, 0x25, 0x12, 0x4b,
	0xab, 0x03, 0x4a, 0x07, 0x1e, 0x99, 0x45, 0x39, 0x93, 0xc0, 0x0a, 0x5d, 0xea, 0x4b, 0x7f, 0x79,
	0xde, 0x1f, 0xba, 0x43, 0x32, 0x0e, 0xad, 0xe1, 0x48, 0x04, 0x54, 0xee, 0xc1, 0x52, 0x2f, 0xb4,
	0xc2, 0xc9, 0x18, 0x93, 0xf1, 0x88, 0xfa, 0x63, 0x82, 0xaa, 0x90, 0x19, 0x73, 0xa4, 0xa8, 0xac,
	0x29, 0xd5, 0xa5, 0xba, 0x56, 0x9b, 0x16, 0x2b, 0x23, 0xa5, 0xbf, 0x72, 0x17, 0xd2, 0x5d, 0x6b,
	0x9f, 0x78, 0x08, 0x41, 0xca, 0xb7, 0x86, 0x84, 0x27, 0xe4, 0x30, 0xff, 0x46, 0x17, 0x21, 0xfd,
	0xd4, 0xf2, 0x26, 0xa4, 0x98, 0xe0, 0xa0, 0x30, 0xee, 0xa5, 0xde, 0xfc, 0x56, 0x5e, 0xa8, 0xfc,
	0x1f, 0x54, 0x9e, 0xd8, 0x23, 0x21, 0x5a, 0x87, 0x8c, 0xc7, 0xbe, 0xd9, 0x76, 0xc9, 0x6a, 0xbe,
	0x7e, 0x61, 0xb6, 0x1d, 0x8f, 0x69, 0xa6, 0x5e, 0x9f, 0x94, 0x17, 0xb0, 0x0c, 0xaa, 0x3c, 0x83,
	0x45, 0x99, 0xea, 0x11, 0x3b, 0xa4, 0x01, 0xaa, 0x43, 0xd6, 0xf5, 0x6d, 0x6f, 0xe2, 0x88, 0xed,
	0xf3, 0x75, 0x34, 0xb7, 0x40, 0x8f, 0x84, 0x72, 0x8d, 0x28, 0x90, 0xe5, 0x90, 0x23, 0x91, 0x93,
	0xf8, 0x54, 0x8e, 0x0c, 0xac, 0xbc, 0x4a, 0x41, 0xfe, 0x3e, 0x9d, 0x04, 0xbe, 0xe5, 0xf5, 0x46,
	0xc4, 0x46, 0xe5, 0xf8, 0x99, 0x9b, 0xf9, 0x77, 0x27, 0xe5, 0xac, 0x74, 0x4b, 0x02, 0xd6, 0x20,
	0x1f, 0x90, 0x91, 0xe7, 0xda, 0xbc, 0x1f, 0x7c, 0xa3, 0x34, 0x8e, 0x43, 0x68, 0x63, 0x7a, 0xf4,
	0xe4, 0x27, 0xaa, 0x90, 0x71, 0xe8, 0x2b, 0x50, 0x0f, 0x02, 0x6b, 0x30, 0x24, 0x7e, 0x58, 0x4c,
	0xf1, 0x9c, 0xd5, 0x59, 0x4e, 0xac, 0xba, 0xda, 0x96, 0x8c, 0x92, 0xf9, 0xd3, 0x2c, 0xb4, 0x0e,
	0x28, 0x0c, 0x2c, 0x7f, 0x6c, 0xd9, 0xac, 0x04, 0xd3, 0x23, 0xfe, 0x20, 0x3c, 0x2c, 0xa6, 0xd7,
	0x94, 0x6a, 0x12, 0x2f, 0xc7, 0x3c, 0x5d, 0xee, 0x40, 0x57, 0x20, 0x17, 0x10, 0xcb, 0x31, 0xa9,
	0xef, 0x1d, 0x17, 0x33, 0x6b, 0x4a, 0x55, 0xc5, 0x2a, 0x03, 0x0c, 0xdf, 0x3b, 0x2e, 0xbd, 0x48,
	0x80, 0x1a, 0x6d, 0x84, 0x56, 0x20, 0x23, 0x17, 0x53, 0xf8, 0x62, 0xd2, 0x42, 0xdb, 0xb0, 0x6c,
	0xd3, 0xe1, 0x28, 0x20, 0xe3, 0x31, 0xdb, 0xd0, 0xa6, 0x0e, 0xb1, 0x39, 0x19, 0x4b, 0xf5, 0xd2,
	0xac, 0xf6, 0xcd, 0x59, 0xc8, 0x26, 0x8b, 0xc0, 0x9a, 0x3d, 0x87, 0xa0, 0x1b, 0x4c, 0x97, 0x34,
	0x20, 0x8c, 0xad, 0x64, 0x35, 0xd7, 0x5c, 0x7e, 0x77, 0x52, 0x5e, 0x8c, 0xb6, 0xef, 0x31, 0x0f,
	0x96, 0x01, 0x48, 0x07, 0x2d, 0x20, 0x07, 0x01, 0x19, 0x1f, 0x9a, 0xae, 0x1f, 0x92, 0xe0, 0xa9,
	0xe5, 0x49, 0xba, 0x2e, 0xd7, 0xc4, 0x85, 0xa8, 0x45, 0x17, 0xa2, 0xd6, 0x92, 0x17, 0xa6, 0xa9,
	0x32, 0xa6, 0x7e, 0xf9, 0xb3, 0xac, 0xe0, 0x0b, 0x32, 0xb9, 0x23, 0x73, 0x51, 0x83, 0xb1, 0x10,
	0x12, 0x9f, 0x37, 0x32, 0xfd, 0xf9, 0x0b, 0xcd, 0xb2, 0x2a, 0xaf, 0x14, 0x80, 0x66, 0x40, 0x9f,
	0x90, 0x80, 0xab, 0x67, 0x1d, 0x12, 0xae, 0x23, 0x05, 0xfb, 0x9f, 0x19, 0x0d, 0xb3, 0x88, 0x5a,
	0xa7, 0x25, 0x7b, 0x97, 0x70, 0x1d, 0x54, 0x05, 0x95, 0xf8, 0xce, 0x88, 0xba, 0x7e, 0x28, 0xee,
	0x53, 0xb3, 0xf0, 0xee, 0xa4, 0xac, 0xb6, 0x25, 0x86, 0xa7, 0x5e, 0x74, 0x0d, 0x16, 0xbf, 0x13,
	0x3a, 0x30, 0x3d, 0x77, 0xe8, 0x86, 0x5c, 0x5a, 0x8b, 0xb8, 0x20, 0xc1, 0x2e, 0xc3, 0x4a, 0x1b,
	0x90, 0xe8, 0xb4, 0xd8, 0xad, 0xfd, 0x81, 0xfa, 0xd3, 0x5b, 0xcb, 0xbe, 0x59, 0x17, 0xc7, 0x93,
	0x83, 0x03, 0xf7, 0x48, 0x5e, 0x5b, 0x69, 0x55, 0x5e, 0xc6, 0x5b, 0x7d, 0x1d, 0xb2, 0x72, 0xb9,
	0xb3, 0xd4, 0x1f, 0xf9, 0xd8, 0x04, 0xd8, 0x27, 0x03, 0x57, 0x48, 0x3f, 0x89, 0x85, 0x81, 0x34,
	0x48, 0x12, 0xdf, 0xe1, 0x65, 0x25, 0x31, 0xfb, 0x44, 0x37, 0x20, 0x39, 0x9e, 0x0c, 0x65, 0x83,
	0x96, 0x63, 0xd3, 0x66, 0xa7, 0x71, 0xbb, 0x37, 0x19, 0x4a, 0x1a, 0x58, 0xcc, 0xd9, 0x62, 0x4a,
	0xff, 0x0b, 0x31, 0x5d, 0x83, 0xc5, 0x7d, 0xcb, 0x7e, 0xe2, 0xfa, 0x03, 0x93, 0x6b, 0x86, 0x6b,
	0x3b, 0x87, 0x0b, 0x12, 0xe4, 0x72, 0x42, 0x5f, 0x82, 0x3a, 0xa4, 0x8e, 0xc9, 0x46, 0x66, 0x31,
	0xcb, 0xab, 0x2b, 0xbd, 0xd7, 0xf5, 0x7e, 0x34, 0x4f, 0x45, 0xdb, 0x7f, 0x66, 0x6d, 0xcf, 0x0e,
	0xa9, 0xc3, 0xf0, 0xca, 0x1e, 0x64, 0xe5, 0x21, 0x18, 0x19, 0x23, 0x2b, 0x08, 0x6f, 0x73, 0xc6,
	0x32, 0x58, 0x18, 0x11, 0x5a, 0xe7, 0x14, 0x49, 0xb4, 0x1e, 0xa1, 0x77, 0x38, 0x49, 0x59, 0x81,
	0xde, 0xb9, 0xa7, 0xfe, 0xfd, 0x6b, 0x59, 0xe1, 0xe3, 0xf3, 0x85, 0x02, 0x79, 0x4c, 0x2c, 0x07,
	0x93, 0xef, 0x27, 0x64, 0xfc, 0xd9, 0xfd, 0x58, 0x81, 0x0c, 0x3d, 0x38, 0x18, 0x93, 0x50, 0x36,
	0x44, 0x5a, 0xbc, 0x4f, 0x1e, 0xb5, 0x9f, 0xf0, 0xed, 0x54, 0x2c, 0x0c, 0xb4, 0x06, 0x05, 0x87,
	0x9a, 0x3e, 0x0d, 0xcd, 0x51, 0x40, 0x8f, 0x8e, 0x79, 0x7b, 0x54, 0x0c, 0x0e, 0xd5, 0x69, 0xb8,
	0xcb, 0x10, 0xc6, 0xe1, 0x90, 0x84, 0x96, 0x63, 0x85, 0x96, 0x98, 0x0f, 0x69, 0x1e, 0x52, 0x88,
	0x40, 0x36, 0x23, 0x2a, 0xcf, 0x13, 0x50, 0x10, 0xb5, 0x9e, 0xf7, 0x79, 0xf9, 0x60, 0xbd, 0x57,
	0x01, 0x9e, 0x05, 0x6e, 0x48, 0xcc, 0x43, 0x62, 0x45, 0x42, 0xca, 0x71, 0x64, 0x87, 0x58, 0x0e,
	0xba, 0x0e, 0xe9, 0x80, 0x4e, 0x42, 0x22, 0x05, 0x15, 0x7b, 0x4f, 0x30, 0x83, 0xb1, 0xf0, 0xa2,
	0x5a, 0x6c, 0x94, 0xa6, 0xe7, 0xc7, 0x6f, 0x24, 0xf5, 0xd8, 0xe0, 0xfc, 0x1f, 0x14, 0xa2, 0x6f,
	0x73, 0x12, 0x78, 0x52, 0x30, 0xf9, 0x08, 0xdb, 0x0b, 0x3c, 0x54, 0x84, 0xac, 0x4d, 0x7d, 0x76,
	0xe3, 0xb9, 0x5c, 0x0a, 0x38, 0x32, 0x2b, 0xbb, 0xb0, 0xd8, 0x18, 0x8d, 0x88, 0x7f, 0xde, 0x96,
	0xc5, 0x56, 0x4c, 0x9f, 0x5e, 0xf1, 0x77, 0x05, 0x96, 0xa2, 0x25, 0xcf, 0xcd, 0xec, 0x94, 0xa2,
	0xc4, 0x47, 0x29, 0x62, 0x47, 0x76, 0x83, 0x71, 0x68, 0xca, 0x36, 0x08, 0xaa, 0xf3, 0x1c, 0x33,
	0x44, 0x2f, 0xca, 0x90, 0xf7, 0xac, 0x59, 0x44, 0x8a, 0x47, 0x00, 0x83, 0x8c, 0xb3, 0x9a, 0x95,
	0x9e, 0x6b, 0x56, 0xe5, 0xa5, 0x02, 0x1a, 0x96, 0x4f, 0x22, 0x39, 0x27, 0x39, 0x65, 0xc8, 0xfb,
	0xe4, 0x68, 0xba, 0xb7, 0x10, 0x09, 0x30, 0x48, 0xee, 0x3d, 0x3d, 0x66, 0xf2, 0xa3, 0xc7, 0x8c,
	0x91, 0x9c, 0x3a, 0x45, 0x32, 0x53, 0xa0, 0x4d, 0x87, 0x6c, 0x8a, 0x8a, 0xc2, 0xa5, 0x55, 0x79,
	0xae, 0xc0, 0x72, 0xac, 0xea, 0x73, 0xf3, 0x7f, 0x9a, 0x94, 0xc4, 0x07, 0x15, 0xfc, 0xd1, 0xba,
	0x2b, 0x3f, 0x29, 0x90, 0xe6, 0x00, 0xba, 0x0b, 0xd9, 0x7d, 0xfe, 0x72, 0x44, 0x3f, 0x51, 0x9f,
	0x78, 0x52, 0xa2, 0x68, 0x76, 0xf4, 0x51, 0xe0, 0x0e, 0xad, 0xe0, 0x58, 0xfe, 0x9f, 0x44, 0x26,
	0xba, 0x09, 0xb9, 0xe8, 0x4d, 0x89, 0x1e, 0xdc, 0xd3, 0x4f, 0xce, 0xcc, 0x2d, 0x7e, 0xea, 0x6e,
	0xfe, 0x98, 0x80, 0x8c, 0x38, 0x27, 0xca, 0x40, 0xc2, 0x78, 0xa0, 0x2d, 0x20, 0x04, 0x4b, 0xf7,
	0x8d, 0x3d, 0xac, 0x37, 0xba, 0x66, 0xfb, 0xdb, 0x4e, 0xaf, 0xdf, 0xd3, 0x14, 0x74, 0x09, 0x96,
	0x23, 0x4c, 0x37, 0xfa, 0xe6, 0x96, 0xb1, 0xa7, 0xb7, 0xb4, 0x04, 0xba, 0x0a, 0x97, 0x75, 0xc3,
	0x8c, 0x3c, 0xbb, 0xb8, 0xf3, 0x75, 0x03, 0x3f, 0x32, 0x9b, 0xd8, 0x78, 0xd0, 0xc6, 0x5a, 0x12,
	0xad, 0x42, 0x89, 0x45, 0x7f, 0xc0, 0x9f, 0x42, 0x2b, 0x80, 0x62, 0xe9, 0x02, 0xee, 0x69, 0x69,
	0x81, 0xf7, 0xe7, 0x1c, 0x5a, 0x06, 0xfd, 0x17, 0x8a, 0xc6, 0xd6, 0x56, 0xaf, 0xdd, 0xe7, 0x45,
	0x3c, 0x6a, 0xf7, 0xcd, 0xc6, 0x37, 0x8d, 0x4e, 0xb7, 0xd1, 0xec, 0xb6, 0xb5, 0x2c, 0xcb, 0xc2,
	0xed, 0xdd, 0x6e, 0x67, 0xb3, 0xd1, 0xef, 0x18, 0xba, 0xb9, 0xd5, 0xe8, 0x74, 0xdb, 0x2d, 0x4d,
	0x45, 0x17, 0x20, 0xff, 0x10, 0x1b, 0xfa, 0xb6, 0x89, 0x8d, 0xbd, 0x7e, 0x5b, 0xcb, 0xa1, 0x8b,
	0xa0, 0x09, 0xe0, 0x21, 0xee, 0xf4, 0xdb, 0xe6, 0x4e, 0xbb, 0xd1, 0xd2, 0xe0, 0xe6, 0x43, 0xd0,
	0xe6, 0x9f, 0x20, 0xa4, 0x42, 0x4a, 0x37, 0xf4, 0xb6, 0xb6, 0xc0, 0xbe, 0xb6, 0x1f, 0x77, 0x76,
	0x35, 0x05, 0x2d, 0x42, 0xee, 0x71, 0xaf, 0xdf, 0xd0, 0x5b, 0x0d, 0xcc, 0x28, 0x00, 0xc8, 0xf4,
	0xf4, 0xc6, 0xee, 0xee, 0x23, 0x2d, 0xc9, 0x16, 0xde, 0x34, 0xf4, 0x7e, 0x5b, 0xef, 0x9b, 0x6d,
	0x7d, 0xd3, 0x68, 0x75, 0xf4, 0x6d, 0x2d, 0x55, 0xff, 0x43, 0x81, 0x8c, 0xe8, 0x27, 0xba, 0x0b,
	0x29, 0x36, 0x56, 0xd1, 0xa5, 0x98, 0x38, 0x66, 0x4f, 0x42, 0x69, 0x65, 0x1e, 0x16, 0x1a, 0xdd,
	0x50, 0xd0, 0x17, 0x90, 0x11, 0x73, 0x03, 0xc5, 0x44, 0x72, 0x6a, 0x38, 0x95, 0x8a, 0xef, 0x3b,
	0x44, 0x7a, 0x55, 0x41, 0x3b, 0x90, 0x9b, 0x2a, 0x1f, 0x95, 0xe2, 0xbb, 0x9c, 0xbe, 0xc4, 0xa5,
	0x2b, 0x67, 0xfa, 0xa2, 0x75, 0x36, 0x94, 0x66, 0xe1, 0xf5, 0xdb, 0x55, 0xe5, 0xcd, 0xdb, 0x55,
	0xe5, 0xaf, 0xb7, 0xab, 0xca, 0x7e, 0x86, 0x47, 0xdf, 0xf9, 0x27, 0x00, 0x00, 0xff, 0xff, 0xa9,
	0xaa, 0x17, 0xa6, 0x1a, 0x0d, 0x00, 0x00,
}
